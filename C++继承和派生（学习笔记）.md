#### C++继承和派生（学习笔记）

---



1. 概念：父亲和儿子的关系，儿子能够继承父亲的一些信息，比如继承鼻子、眼睛。也有一些基因是继承不到的，属于private私有属性。

   > 与c的结构体类似，不同的是，类除了包含变量，还包含函数。
   >
   > 在这里，我们可以理解为变量就是对象，函数就是处理计算变量的，称之为面向对象。

2. 三种继承方式

   public、protected、private是用来指出基类成员在派生类中的最高访问权限。

   > 访问权限：public> protected > private
   >
   > 比如public继承的话就是通杀，父类的各种属性照搬过来。
   >
   > 而protected继承的时候，protected是继承的最高权限，因此父类的public属性变成protected属性，其他的照搬
   >
   > private继承同理

   延伸：using的用法

   > 改变基类中public和protected成员的访问权限。
   >
   > 为什么呢，因为private成员在派生类中无论如何也看不到了啦

   延伸：突破访问权限的窍门（弯路）

   > 运用指针，根据存放规律来做基地址+offset偏移量

3. 基类与派生类名字屏蔽

   当有同一个名字的函数，出现在父类和子类中。程序会默认优先用子类的，从而相当于屏蔽了基类的同名函数。所以就不能构成重载函数了。

   延伸：重载函数的知识，两个函数同名，它必须在参数类型、个数、顺序上，至少有一个不同，才能存在重载函数。（这里不详细展开）

4. 加钱得到的思想

   > 作用域思想：
   >
   > 把类想成作用域，基类是最外围最大的作用域，每一次派生，都在其作用域中再挖出一个小的作用域。正因如此，派生类才能如此顺利地调用基类的东西。

   > 内存模型：
   >
   > 派生类的变量包含（按顺序）：基类的，第一个子类的，第二个子类的。
   >
   > 并且存在和基类不同的地方。
   >
   > 优点：访问效率高，能直接在派生类找到基类的成员变量，而无需经过好几层的计算。

5. 构造函数与析构函数

   执行顺序：先父类，再子类。

   默认规则：如果在声明一个类的初始化的时候，不额外指出用哪个构造函数，则默认调用不带参数的构造函数。

   格式：

   > Student::Student(char *name, int age, float score): m_score(score), People(name, age){ }
   
   关键：不能被继承
   
   类似堆栈的一个进入方式
   
6. 虚类继承

   > 目的：解决多继承时，容易出现的命名冲突和数据重复。

   > 注意的地方：派生类的构造函数在虚继承中不仅负责初始化它的直接基类，还得负责初始化它的间接基类